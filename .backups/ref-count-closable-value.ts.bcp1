import { type Abortable, abortify } from '@xstd/abortable';

/* TYPES */

export interface OpenClosableValue<GValue> {
  (signal: AbortSignal): PromiseLike<ClosableValue<GValue>> | ClosableValue<GValue>;
}

export interface ClosableValue<GValue> {
  readonly value: GValue;
  readonly close: CloseClosableValue;
}

export interface CloseClosableValue {
  (reason: unknown, hook: AcquireCloseHook): PromiseLike<void> | void;
}

export interface AcquireCloseHook {
  (): CloseHook;
}

export interface CloseHook {
  readonly resolve: () => void;
  readonly reject: (reason?: unknown) => void;
  readonly signal: AbortSignal;
}

// derived

export interface DerivedClosableValue<GValue> {
  readonly value: GValue;
  readonly close: CloseDerivedClosableValue;
}

export interface CloseDerivedClosableValue {
  (reason?: unknown): Promise<void>;
}

/* CLASS */

export class RefCountClosableValue<GValue> {
  readonly #open: OpenClosableValue<GValue>;

  #count: number;

  #openController: AbortController | undefined;
  #openPromise: Promise<ClosableValue<GValue>> | undefined;

  #closeController: AbortController | undefined;
  #closePromise: Promise<void> | undefined;

  constructor(open: OpenClosableValue<GValue>) {
    this.#open = open;
    this.#count = 0;
  }

  #close(close: CloseClosableValue, reason: unknown): Promise<void> {
    this.#closeController = new AbortController();
    const signal: AbortSignal = this.#closeController.signal;

    let hookPromise: Promise<void> | undefined;

    const closePromise: Promise<void> = Promise.try(close, reason, (): CloseHook => {
      if (hookPromise !== undefined) {
        throw new Error('Close hook locked.');
      }
      const { promise, resolve } = Promise.withResolvers<void>();
      hookPromise = promise;
      return {
        resolve: (): void => resolve(),
        reject: (reason?: unknown): void => {
          if (reason !== signal.reason) {
            reportError(reason);
          }
          resolve();
        },
        signal,
      };
    });

    hookPromise ??= closePromise.catch((): void => {});

    this.#closePromise = hookPromise.finally((): void => {
      if (!signal.aborted) {
        this.#openPromise = undefined;
      }
      this.#closeController = undefined;
      this.#closePromise = undefined;
    });

    return closePromise;
  }

  async open({ signal }: Abortable = {}): Promise<DerivedClosableValue<GValue>> {
    signal?.throwIfAborted();

    if (this.#closePromise !== undefined) {
      this.#closeController!.abort();

      await abortify(this.#closePromise, { signal });
    }

    this.#count++;

    if (this.#openPromise === undefined) {
      const openController: AbortController = new AbortController();
      this.#openController = openController;
      this.#openPromise = Promise.try(this.#open, openController.signal).then(
        (value: ClosableValue<GValue>): ClosableValue<GValue> => {
          openController.abort();
          if (this.#openController === openController) {
            this.#openController = undefined;
          }
          return value;
        },
        (error: unknown): never => {
          openController.abort();
          if (this.#openController === openController) {
            this.#openController = undefined;
            this.#openPromise = undefined;
          }
          throw error;
        },
      );
    }

    try {
      const { value, close }: ClosableValue<GValue> = await abortify(this.#openPromise, {
        signal,
      });

      let closed: boolean = false;

      return {
        value,
        close: async (reason?: unknown): Promise<void> => {
          if (closed) {
            throw new Error('Already closed.');
          }
          closed = true;

          this.#count--;

          if (this.#count === 0) {
            await this.#close(close, reason);
          }
        },
      };
    } catch (error: unknown) {
      try {
        // => failed to open shared resource OR signal aborted
        this.#count--;

        if (this.#count === 0) {
          this.#openController?.abort(error);
          // safeguard: if `openPromise` fulfills (however, rejection is expected), we close it immediately
          await this.#close((await this.#openPromise).close, error);
        }
      } finally {
        throw error;
      }
    }
  }
}
